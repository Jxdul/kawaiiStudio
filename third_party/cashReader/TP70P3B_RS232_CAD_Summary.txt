TP70P3B RS232 Bill Validator — LLM-Friendly Integration Spec (CAD $5 / $10)
===============================================================================

GOAL
----
Integrate a TP70P3B-family bill validator configured in RS232 protocol mode.
This unit accepts ONLY CAD $5 and CAD $10.

KEY FACTS (HIGH CONFIDENCE)
---------------------------
- Transport: RS232 via Windows COM port (PCIe RS232 adapter).
- Serial config: 9600 baud, 8 data bits, EVEN parity, 1 stop bit, no flow control.  (9600 8E1)
- Protocol: single-byte commands/events (byte-oriented, not ASCII).
- Accepted denominations (your device): CAD $5 and CAD $10 only.
- Bill type mapping (confirmed by your testing):
    0x40 -> CAD $5   (Bill Type 1)
    0x41 -> CAD $10  (Bill Type 2)

CONCEPTS
--------
- "Escrow": validator holds the bill and waits for host decision.
- Host must respond quickly (within a few seconds) or the validator may auto-reject.

I/O OVERVIEW
============
HOST -> VALIDATOR (TX commands)
------------------------------
All are 1 byte:

0x3E : ENABLE intake (accept bills)
0x5E : DISABLE intake (inhibit / stop taking bills)
0x0C : STATUS REQUEST (poll)
0x02 : ACCEPT / STACK bill (also used as power-up ACK)
0x0F : REJECT escrow bill (send bill back)
0x18 : HOLD bill in escrow (optional; later send 0x02 or 0x0F)
0x30 : RESET validator

VALIDATOR -> HOST (RX events/status)
-----------------------------------
All are 1 byte:

Power/Handshake:
0x80 : Power-up notice (validator booted)
0x8F : Handshake complete (after host ACK)

Bill flow:
0x81 : "Bill validated event incoming" (next byte will be bill type)
0x40..0x44 : Bill Type 1..5 (your unit uses 0x40 and 0x41)
0x10 : Stack/accept completed (credit should be committed now)
0x11 : Reject completed (no credit)

Fault/status codes (often from polling 0x0C):
0x20 : Motor failure
0x21 : Checksum error
0x22 : Bill jam
0x23 : Bill removed
0x24 : Stacker open
0x25 : Sensor problem
0x27 : "Bill fish" / anti-fraud condition (vendor-specific wording)
0x28 : Stacker problem
0x29 : Bill reject
0x2A : Invalid command

Normal poll responses can also include:
0x3E : Enabled status
0x5E : Inhibited status

RECOMMENDED DRIVER BEHAVIOR
===========================

STATE VARIABLES
---------------
- connected: bool
- enabled: bool
- expect_bill_type: bool
- pending_value_cad: int | null   (only set after you see bill type)
- last_error: byte | null

STARTUP SEQUENCE (robust)
-------------------------
1) Open COM port with 9600 8E1, no flow control.
2) Send 0x3E (ENABLE).
3) Begin a poll loop: send 0x0C every 250–500 ms until you see any valid reply
   (0x3E / 0x5E / 0x20..0x2A / etc.). If you see valid replies, mark connected=true.

POWER-UP HANDSHAKE (if observed)
--------------------------------
If you ever receive 0x80:
- Immediately send 0x02 (ACK).
- Then send 0x3E (ENABLE).
- Expect (often) 0x8F afterwards.

BILL HANDLING (credit only after STACK CONFIRM)
-----------------------------------------------
1) RX 0x81  => set expect_bill_type = true
2) Next RX byte should be bill type (0x40..0x44):
   - If RX == 0x40: pending_value_cad = 5
   - If RX == 0x41: pending_value_cad = 10
   - If RX == 0x42: pending_value_cad = 20
   - Otherwise: pending_value_cad = null (unknown/disabled)
3) Decide:
   - If pending_value_cad is 5 or 10 or 20: TX 0x02 (ACCEPT/STACK)
   - Else: TX 0x0F (REJECT)
4) Wait for result:
   - If RX == 0x10 (stack complete) and pending_value_cad != null:
       CREDIT the amount (add to balance), then pending_value_cad = null
   - If RX == 0x11 (reject complete):
       pending_value_cad = null

IMPORTANT: Do NOT credit on 0x40/0x41 alone. Credit ONLY when you see 0x10.

ENABLE/DISABLE (kiosk control)
------------------------------
- When your UI is not ready to take money, TX 0x5E (DISABLE).
- When ready, TX 0x3E (ENABLE).
- Optionally confirm using status poll (0x0C).

ERROR HANDLING
--------------
- If you receive any 0x20..0x2A:
  - Log it with a timestamp.
  - Optionally TX 0x5E (DISABLE) to stop intake.
  - Show an operator message (jam/stacker open/etc.).
  - Keep polling 0x0C until status clears, then TX 0x3E (ENABLE).

RESET
-----
- TX 0x30 to reset.
- After reset, you may see 0x80 again. Handle handshake and re-enable.

MINIMAL PSEUDOCODE (LLM-READY)
==============================
on_start():
  open_serial(9600, 8E1)
  send(0x3E)         // enable
  start_poll_timer()

on_poll_timer():
  send(0x0C)

on_byte_received(b):
  log_rx(b)

  if b == 0x80:
    send(0x02)       // power-up ACK
    send(0x3E)       // enable
    connected = true
    return

  if b == 0x8F:
    connected = true
    return

  if b == 0x81:
    expect_bill_type = true
    pending_value_cad = null
    return

  if expect_bill_type:
    expect_bill_type = false
    if b == 0x40: pending_value_cad = 5
    elif b == 0x41: pending_value_cad = 10
    else: pending_value_cad = null

    if pending_value_cad != null:
      send(0x02)     // accept/stack
    else:
      send(0x0F)     // reject
    return

  if b == 0x10:      // stack complete
    if pending_value_cad != null:
      credit(pending_value_cad)
      pending_value_cad = null
    return

  if b == 0x11:      // reject complete
    pending_value_cad = null
    return

  if 0x20 <= b <= 0x2A:
    last_error = b
    send(0x5E)       // optional: disable intake
    notify_operator(error_message(b))
    return

NOTES ABOUT DIP SWITCHES
========================
- Your unit is confirmed in RS232 protocol mode (not Pulse).
- DIP switch meaning varies by currency dataset and by mode; power-cycle after DIP changes.
- Your current config accepts only the first two bill types (fits $5/$10-only operation).

TROUBLESHOOTING QUICK CHECKLIST
===============================
- Wrong serial settings => garbage/no data. Ensure 9600 8E1.
- No bytes received => wrong COM port, wiring, or device not in RS232 mode.
- Bills insert but always reject => host not responding (must send 0x02 quickly) or disabled (0x5E).
- Crediting too early => only credit after 0x10.

END
